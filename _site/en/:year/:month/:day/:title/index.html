<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>How do hash tables work</title> <meta name="description" content=""> <link rel="stylesheet" href="/css/main.css"> <link rel="stylesheet" href="/css/custom_css.css"> <link rel="canonical" href="http://karlheinzniebuhr.github.io/en/:year/:month/:day/:title/"> <link rel="alternate" type="application/rss+xml" title="Karl's Blog" href="http://karlheinzniebuhr.github.io/feed.xml" /> <!-- favicon --> <link rel="shortcut icon" href="/images/favicon.ico"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-37427094-3', 'auto'); ga('send', 'pageview'); </script> <!-- Selection-sharer --> <script src="http://code.jquery.com/jquery-latest.js"></script> <link rel="stylesheet" href="selection-sharer/dist/selection-sharer.css" /> <script src="selection-sharer/src/selection-sharer.js"></script> <script> var sharer = new SelectionSharer('p'); </script> </head> <body> <header class="site-header"> <div class="wrapper"> <a class="site-title" href="/">Karl's Blog</a> <nav class="site-nav"> <a href="#" class="menu-icon"> <svg viewBox="0 0 18 15"> <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/> <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/> <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/> </svg> </a> <div class="trigger"> <!-- <a class="page-link" href="/fitness/">Fitness</a> --> <a class="page-link" href="/ES/">ES</a> <a class="page-link" href="/about/">About</a> <!-- <a class="page-link" href="/ES/index.html">Karl's Blog</a> --> </div> </nav> </div> </header> <div class="page-content"> <div class="wrapper"> <div class="post"> <header class="post-header"> <h1 class="post-title">How do hash tables work</h1> <script src="/share-button/share-button.min.js"></script> <link href="/share-button/share-button.css" rel="stylesheet"> <share-button></share-button> <script> var shareButton = new ShareButton(); </script> <p class="post-meta">Jan 28, 2016</p> </header> <article class="post-content"> <p>In this post I will cover and expand a little bit on something from the <a href="https://www.udacity.com/courses/cs101">CS101 Course of Udacity</a> with <a href="https://twitter.com/udacitydave">David Evans</a>. If you like this topic I definitively recommend you to check it out, it’s free.</p> <p><strong>Introduction</strong><br /> <em>“The problem of measuring cost, analysing algorithms and designing algorithms that work well when the input size scales, is one of the most important and interesting problems in computer science.”</em><br /> For example when looking up a value in an index of values, or key-value pairs. Normally the lookup time would increase linearly with the input size. If you have 10 values the algorithm would have to check them one by one, in the worst scenario all 10 values, before the right one is either found or the list is exhausted. If the size of values doubles (20 values), the lookup time would take twice as long in the worst case. But what if there is a better way to scale? There are different approaches, like <a href="https://en.wikipedia.org/wiki/Search_tree">search trees</a> for instance. On average search trees have a <a href="https://en.wikipedia.org/wiki/Time_complexity">time complexity</a> of O(log n). This means that if the number of values is 16, the algorithm has to complete at least 4 <em>‘steps’</em> to find the position of the value –&gt; <strong>log2(16) = 4</strong>.<br /> Of course the best thing would be to decouple the <strong>time</strong> (number of operations/seconds) completely from the <strong>input size</strong>. This is what hash tables enable to do. On average each lookup is independent from the number of elements stored in the table. Hash tables have a <strong><em>time complexity of O(1)</em></strong>, meaning that they perform lookups in <strong><em>constant time</em></strong>, rather than <strong><em>linear time</em></strong>. This is very important as many types of software depend on constant time in order to operate efficiently, like search engines and database indexes.</p> <p><img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/common_time_complexities.jpg" alt="" /></p> <p>So how exactly does a hash table work?<br /> The basic concept behind hash tables is to do the computation just once on the keyword instead of the entire index. I’ll try to illustrate it graphically.</p> <p><img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/linear_search.png" alt="" /> <img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/hash_function.png" alt="" /></p> <p>There are multiple ways to compute a hash, a simple way would be to base it on the first letter in each keyword, similar to an alphabetic index of a book. Each entry in the index of the table corresponds to a letter and contains all the keywords beginning with that letter. This isn’t the best method. The problem with this method is that it can only speed up the look up by a factor of 26, as there are 26 letters in the alphabet (26 buckets for our words). And this again would only be efficient if the buckets had the same size, which isn’t the case because there are more words starting with S and T than with X and Q for example. Thus the buckets would have very different sizes.<br /> This can be fixed by solving two problems: - The value must be a function of the whole word<br /> - The words (values) must be distributed evenly between the buckets</p> <p>In Python this data structure or type is called a dictionary. It provides the exact same functionality, so you could use it directly. But in order to better understand how a hash table works, let’s make one.</p> <p>Our hash function, called hash_string, takes a string and the number of buckets b as input and outputs a number between 0 and b-1. You can use two Python operators to convert characters to numbers and viceversa. The <strong>ord</strong> (for ordinal) which converts a one letter string into a number, and <strong>chr</strong> (for character) which turns a number back into a one-letter string. This two operators are inverses which means that one function is the reverse of the other.</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="nb">ord</span><span class="p">(</span><span class="o">&lt;</span><span class="n">one</span><span class="o">-</span><span class="n">letter</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">)</span> <span class="err">→</span> <span class="n">Number</span>
<span class="nb">chr</span><span class="p">(</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span><span class="p">)</span> <span class="err">→</span> <span class="o">&lt;</span><span class="n">one</span><span class="o">-</span><span class="n">letter</span> <span class="n">string</span><span class="o">&gt;</span>

<span class="c"># try this in the python console</span>
<span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">))</span> <span class="o">--&gt;</span> <span class="s">&#39;a&#39;</span></code></pre></div> <p>What is needed next is a way to map the keywords to a range of 0 to b-1. For this you can use the modulus operator. The modulus operator (%) takes a number, divides it by the modulus and <strong>returns the remainder</strong>. <br /> Example:</p> <div class="highlight"><pre><code class="language-text" data-lang="text">14%12 = 2</code></pre></div> <p>In Python:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="mi">14</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span>
<span class="mi">2</span></code></pre></div> <p>Now making use of the modulus operator, you want a way to calculate the hash string, using <strong><em>not just the first letter</em></strong> of the word like this:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bad_hash_string</span> <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">buckets</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="n">keyword</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="n">buckets</span> <span class="c"># output is the bucket based on the first letter of the keyword</span></code></pre></div> <p>The example above would result in a <strong><em>bad distribution of values</em></strong> in the buckets as you will see in a moment. To prevent this from happening you can just sum up every number coming from the <strong>ord()</strong> operator of every letter and then perform modulus of the sum like this:</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bad_hash_string</span> <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">buckets</span><span class="p">):</span>
<span class="k">def</span> <span class="nf">hash_string</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">buckets</span><span class="p">):</span>
  <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">keyword</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">s</span> <span class="o">%</span> <span class="n">buckets</span> <span class="c"># modulus performed here</span></code></pre></div> <p>Let’s test both hash functions with a sample text from the web. Check out the <a href="#code">code download link</a> for the complete code so you can try it for yourself. Firstly save the following text file to the folder your python code is located. http://www.gutenberg.org/cache/epub/1661/pg1661.txt</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;pg1661&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">words</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="c"># initialize all the words from the page &#39;Adventures of Sherlock Holmes&#39;</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">test_hash_function</span><span class="p">(</span><span class="n">bad_hash_string</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span> <span class="c"># obtain the counts for the bad hash string</span>
<span class="k">print</span> <span class="s">&#39;bad hash_string:  &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="c"># [725, 1509, 1066, 1622, 1764, 834, 1457, 2065, 1398, 750, 1045, 935]</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">test_hash_function</span><span class="p">(</span><span class="n">hash_string</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span> <span class="c"># find the distribution for the good hash function</span>
<span class="k">print</span> <span class="s">&#39;good hash_string:  &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="c"># [1363, 1235, 1252, 1257, 1285, 1256, 1219, 1252, 1290, 1241, 1217, 1303]</span></code></pre></div> <p>As you can see, in the second print the values are distributed much more evenly throughout the buckets than in the first one, where the distribution is a function of the first letter only.</p> <h4 id="part-2-benchmarking">Part 2: Benchmarking</h4> <p><em>Speed difference of a Hash table and a normal lookup</em> Notice: This is by no means a perfect benchmark, it’s just meant to illustrate the speed improvement gained by using a simple hash table implementation.</p> <p>For this test I will use the <a href="https://github.com/Karlheinzniebuhr/pythonbenchmark">pythonbenchmark</a> library, and a big index which I’ll generate with the make_big_index function. <a href="#code">Jump to the bottom of the page for the complete code</a>. The <strong>lookup function</strong> is the one which just goes sequentially through the entire index and compares every single key. This operation as we will see, grows <strong>proportionally</strong> with the <strong>index size</strong>. The second function called <strong>hashtable_lookup</strong> is our simple hash table function, which instead of running through the entire index, just jumps directly to the right bucket. This should happen in constant time, independently of the index size.</p> <p>Let’s test the two functions with a tiny index of just 10 values. And run the test 10 times.</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">index10</span> <span class="o">=</span> <span class="n">make_big_index</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c"># compare_function(function1, function2, number_of_tests, htable, lookup_key)</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">hashtable_lookup</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">index10</span><span class="p">,</span> <span class="s">&#39;udacity&#39;</span><span class="p">)</span></code></pre></div> <p>Output:<br /> <img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/10.png" alt="" /></p> <p>So far the lookup function is faster than the hash table lookup. This is probably due to the fact that the index size is so tiny, the cost of going through the 10 values is cheaper than calculating the hash of the keyword.<br /> Lets test with an index of 100.</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">index100</span> <span class="o">=</span> <span class="n">make_big_index</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="c"># compare_function(function1, function2, number_of_tests, htable, lookup_key)</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">hashtable_lookup</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">index100</span><span class="p">,</span> <span class="s">&#39;udacity&#39;</span><span class="p">)</span></code></pre></div> <p><img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/100.png" alt="" /></p> <p>Index: 1000</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">index1000</span> <span class="o">=</span> <span class="n">make_big_index</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="c"># compare_function(function1, function2, number_of_tests, htable, lookup_key)</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">hashtable_lookup</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">index1000</span><span class="p">,</span> <span class="s">&#39;udacity&#39;</span><span class="p">)</span></code></pre></div> <p><img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/1000.png" alt="" /></p> <p>Index: 100000</p> <div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">index100000</span> <span class="o">=</span> <span class="n">make_big_index</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
<span class="c"># compare_function(function1, function2, number_of_tests, htable, lookup_key)</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">hashtable_lookup</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">index100000</span><span class="p">,</span> <span class="s">&#39;udacity&#39;</span><span class="p">)</span></code></pre></div> <p><img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/100000.png" alt="" /></p> <p>Notice how much faster the hash table is with an index of just 100.000<br /> This is because as the size of the index grows, the time difference between a normal lookup and a hash table grows linearily with the input size as shown in this graphic.<br /> <img src="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/images/hash/hash_table_efficiency.png" alt="" /></p> <p>Now imagine what would happen with an index of billions of entries like a search engine. Without some kind of hash table something bad would happen, you can do the math :)</p> <p>For the sake of keeping this Blogpost short, I won’t dive into the complete code but you can download it and try it out for yourself. It’s pretty basic and by no means the best implementation of a hash table, but I think it will help to understand how a hash table works and the underlying concept. There are also <a href="https://en.wikipedia.org/wiki/Hash_table#Drawbacks">downsides</a> to hash tables, like collisions. This implementation uses <a href="http://www.csl.mtu.edu/cs2321/www/newLectures/17_Hash_Tables_Collisions.html">separate chaining</a> to resolve collisions.<br /> Hope this helps<br /> Karl</p> <h4 id="a-namecode-hrefhttpsrawgithubusercontentcomkarlheinzniebuhrkarlheinzniebuhrgithubiomastercodehashtablepydownload-codea"><a name="code" href="https://raw.githubusercontent.com/Karlheinzniebuhr/karlheinzniebuhr.github.io/master/code/hash_table.py">Download Code</a></h4> </article> <p class="rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a> or <a href="http://eepurl.com/by15bT">via E-mail</a></p> </div> <!-- Add Disqus comments. --> <div id="disqus_thread"></div> <script type="text/javascript"> /* * * CONFIGURATION VARIABLES * * */ var disqus_shortname = 'karlsjekyllblog'; /* * * DON'T EDIT BELOW THIS LINE * * */ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> </div> </div> <footer class="site-footer"> <div class="wrapper"> <!-- <h2 class="footer-heading">Karl's Blog</h2> --> <div class="footer-col-wrapper"> <div class="footer-col footer-col-2" style="width:180px;"> <ul class="social-media-list"> <li> <a href="https://github.com/Karlheinzniebuhr"> <span class="icon icon--github"> <svg viewBox="0 0 16 16"> <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/> </svg> </span> <span class="username">Github</span> </a> </li> </ul> </div> <div class="footer-col footer-col-2"> <ul class="social-media-list"> <li> <a href="https://twitter.com/NiebuhrKarl"> <span class="icon icon--twitter"> <svg viewBox="0 0 16 16"> <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809 c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/> </svg> </span> <span class="username">Twitter</span> </a> </li> </ul> </div> <div class="footer-col footer-col-2"> <ul class="social-media-list"> <li> <a href="https://facebook.com/Karlheinzniebuhr"> <span class="icon"> <svg width="15" height="15" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 167.657 167.657" style="enable-background:new 0 0 167.657 167.657;" xml:space="preserve"> <path style="fill: #828282;" d="M83.829,0.349C37.532,0.349,0,37.881,0,84.178c0,41.523,30.222,75.911,69.848,82.57v-65.081H49.626 v-23.42h20.222V60.978c0-20.037,12.238-30.956,30.115-30.956c8.562,0,15.92,0.638,18.056,0.919v20.944l-12.399,0.006 c-9.72,0-11.594,4.618-11.594,11.397v14.947h23.193l-3.025,23.42H94.026v65.653c41.476-5.048,73.631-40.312,73.631-83.154 C167.657,37.881,130.125,0.349,83.829,0.349z"/> </svg> </span> <span class="username">Facebook</span> </a> </li> </ul> </div> <div class="footer-col footer-col-3"> <p class="text">A place where I share my stuff </p> </div> </div> </div> </footer> </body> </html>
